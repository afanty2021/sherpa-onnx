# 故障排除

<cite>
**本文档引用的文件**   
- [README.md](file://README.md)
- [CMakeLists.txt](file://CMakeLists.txt)
- [setup.py](file://setup.py)
- [pom.xml](file://pom.xml)
- [log.h](file://sherpa-onnx/csrc/log.h)
- [log.cc](file://sherpa-onnx/csrc/log.cc)
- [vad.cc](file://harmony-os/SherpaOnnxHar/sherpa_onnx/src/main/cpp/vad.cc)
- [circular-buffer.cc](file://sherpa-onnx/csrc/circular-buffer.cc)
- [circular-buffer-test.cc](file://sherpa-onnx/csrc/circular-buffer-test.cc)
- [CircularBuffer.cs](file://scripts/dotnet/CircularBuffer.cs)
- [my-patch.diff](file://harmony-os/SherpaOnnxHar/sherpa_onnx/src/main/cpp/my-patch.diff)
- [test-version.swift](file://swift-api-examples/test-version.swift)
- [test_version.kt](file://kotlin-api-examples/test_version.kt)
</cite>

## 目录
1. [问题分类体系](#问题分类体系)
2. [构建错误](#构建错误)
3. [运行时错误](#运行时错误)
4. [性能问题](#性能问题)
5. [兼容性问题](#兼容性问题)
6. [错误诊断流程](#错误诊断流程)
7. [平台和语言绑定特定指南](#平台和语言绑定特定指南)
8. [性能瓶颈分析](#性能瓶颈分析)
9. [内存泄漏检测](#内存泄漏检测)

## 问题分类体系

sherpa-onnx项目中的问题可以分为四大类：构建错误、运行时错误、性能问题和兼容性问题。构建错误通常与编译环境、依赖库和配置选项有关。运行时错误涉及模型加载、音频处理和API调用过程中的异常。性能问题包括推理延迟高、CPU/内存占用过高等。兼容性问题则涉及不同操作系统、硬件平台和编程语言绑定的适配问题。

**Section sources**
- [README.md](file://README.md)
- [CMakeLists.txt](file://CMakeLists.txt)

## 构建错误

构建错误主要源于CMake配置、依赖库缺失和编译器兼容性问题。在`CMakeLists.txt`中，项目通过大量option控制构建行为，如`SHERPA_ONNX_ENABLE_PYTHON`、`SHERPA_ONNX_ENABLE_GPU`等。如果这些选项配置不当，会导致构建失败。例如，启用GPU支持时需要确保CUDA工具包已安装，否则会在运行时出现错误。

另一个常见问题是依赖库缺失。项目依赖于ONNX Runtime、portaudio等外部库。在Linux系统上，如果缺少alsa开发库，构建过程会提示无法找到`alsa/asoundlib.h`，并建议安装`libasound2-dev`包。类似地，Android构建需要正确配置NDK和JNI接口。

Python包构建通过`setup.py`管理，其中定义了CMake扩展和二进制文件安装逻辑。如果环境变量`SHERPA_ONNX_CMAKE_ARGS`配置错误，可能导致二进制文件无法正确生成。Java和Android构建使用Maven，`pom.xml`文件定义了项目元数据和打包方式。

**Section sources**
- [CMakeLists.txt](file://CMakeLists.txt)
- [setup.py](file://setup.py)
- [pom.xml](file://pom.xml)

## 运行时错误

运行时错误通常表现为程序崩溃、断言失败或异常抛出。sherpa-onnx使用自定义的日志和断言系统来处理错误。在`log.h`中定义了`SHERPA_ONNX_CHECK`系列宏，用于条件检查。当检查失败时，会打印详细的错误信息和堆栈跟踪，然后抛出`std::runtime_error`异常。

日志系统支持不同级别（TRACE、DEBUG、INFO、WARNING、ERROR、FATAL），可通过环境变量`SHERPA_ONNX_LOG_LEVEL`控制输出级别。错误发生时，系统会自动打印堆栈跟踪，帮助定位问题根源。对于Python用户，建议使用gdb调试，命令为`gdb --args python /path/to/your/code.py`。

在HarmonyOS的JNI代码中，参数验证是常见的错误源。例如，在`vad.cc`中，如果传递的参数数量不正确或类型不匹配，会通过`Napi::TypeError::New(env, ...).ThrowAsJavaScriptException()`抛出JavaScript异常。类似的，在.NET绑定中，`CircularBuffer.cs`使用`DllImport`调用原生函数，如果句柄无效会导致访问冲突。

**Section sources**
- [log.h](file://sherpa-onnx/csrc/log.h)
- [log.cc](file://sherpa-onnx/csrc/log.cc)
- [vad.cc](file://harmony-os/SherpaOnnxHar/sherpa_onnx/src/main/cpp/vad.cc)
- [CircularBuffer.cs](file://scripts/dotnet/CircularBuffer.cs)

## 性能问题

性能问题主要体现在推理延迟高、CPU占用率高和内存使用过大。项目通过多线程和异步I/O优化性能。在`offline-websocket-server.cc`中，使用asio库创建了I/O线程池和工作线程池，分别处理网络通信和计算任务。线程数量可通过参数配置，但过多线程可能导致上下文切换开销增加。

内存管理是性能关键。`circular-buffer.cc`实现了循环缓冲区，用于流式音频处理。该实现通过预分配内存和智能拷贝策略减少内存分配开销。测试代码`circular-buffer-test.cc`验证了各种边界情况下的正确性，如缓冲区满、空和跨边界访问。

对于WebAssembly构建，性能优化尤为重要。在`CMakeLists.txt`中，WASM相关选项如`SHERPA_ONNX_ENABLE_WASM_ASR`控制是否启用特定功能。由于WASM的内存限制，需要特别注意模型大小和内存使用。

**Section sources**
- [offline-websocket-server.cc](file://sherpa-onnx/csrc/offline-websocket-server.cc)
- [circular-buffer.cc](file://sherpa-onnx/csrc/circular-buffer.cc)
- [circular-buffer-test.cc](file://sherpa-onnx/csrc/circular-buffer-test.cc)
- [CMakeLists.txt](file://CMakeLists.txt)

## 兼容性问题

兼容性问题涉及不同平台、架构和语言绑定的适配。项目支持x64、x86、arm64、arm32和riscv64等多种架构，以及Android、iOS、Windows、macOS、Linux和HarmonyOS等操作系统。每个平台的构建配置和依赖管理都有所不同。

在HarmonyOS的`my-patch.diff`中，展示了对N-API的补丁，修复了`napi_get_arraybuffer_info`函数调用中缺少字节长度参数的问题。这种底层API差异是跨平台开发中常见的兼容性挑战。

语言绑定方面，项目提供了C++、C、Python、Java、C#、Go、JavaScript、Swift、Kotlin、Dart、Rust和Pascal等多种API。不同语言的内存管理和异常处理机制差异较大，需要仔细处理。例如，Swift的`test-version.swift`和Kotlin的`test_version.kt`都提供了版本查询接口，但调用方式和错误处理机制完全不同。

**Section sources**
- [my-patch.diff](file://harmony-os/SherpaOnnxHar/sherpa_onnx/src/main/cpp/my-patch.diff)
- [test-version.swift](file://swift-api-examples/test-version.swift)
- [test_version.kt](file://kotlin-api-examples/test_version.kt)

## 错误诊断流程

诊断sherpa-onnx问题的标准流程如下：
1. 收集日志：设置`SHERPA_ONNX_LOG_LEVEL=DEBUG`获取详细日志输出。
2. 分析堆栈跟踪：查看错误发生时的函数调用栈，定位问题根源。
3. 验证输入：检查模型文件、音频数据和API参数是否符合要求。
4. 复现问题：使用最小可复现代码隔离问题。
5. 调试：对于复杂问题，使用gdb等调试工具进行单步调试。

对于Python用户，建议在调试版本下运行，以便获得更详细的错误信息。如果问题与特定硬件相关（如NPU），需要检查相应SDK是否正确安装和配置。

**Section sources**
- [log.h](file://sherpa-onnx/csrc/log.h)
- [log.cc](file://sherpa-onnx/csrc/log.cc)

## 平台和语言绑定特定指南

### Android
Android构建使用Gradle，需要正确配置NDK路径和ABI。JNI接口在`sherpa-onnx/jni/`目录下，注意32位ARM设备的内存对齐问题。在`CMakeLists.txt`中，Android特有的链接器标志`-Wl,-z,max-page-size=16384`用于解决内存映射问题。

### iOS
iOS构建使用Xcode，注意LTO（链接时优化）可能导致架构信息丢失的问题。在`CMakeLists.txt`中，已禁用iOS的IPO以避免此问题。

### WebAssembly
WASM构建需要Emscripten工具链。在`CMakeLists.txt`中，WASM相关选项控制功能启用。由于浏览器安全限制，某些功能（如文件系统访问）需要特殊处理。

### Python
Python包通过`setup.py`构建，支持CUDA加速。通过设置环境变量`SHERPA_ONNX_CMAKE_ARGS`可以启用GPU支持。安装后，二进制文件会自动安装到`Scripts`（Windows）或`bin`（其他平台）目录。

**Section sources**
- [CMakeLists.txt](file://CMakeLists.txt)
- [setup.py](file://setup.py)

## 性能瓶颈分析

性能瓶颈分析应从CPU、内存和I/O三个方面入手：
1. CPU分析：使用性能分析工具（如perf、VTune）识别热点函数。
2. 内存分析：监控内存分配和释放，避免频繁的小内存分配。
3. I/O分析：测量数据加载和预处理时间，优化文件读取和音频解码。

在流式处理场景中，注意缓冲区大小和处理延迟的平衡。过小的缓冲区会导致频繁的I/O操作，过大的缓冲区会增加端到端延迟。

**Section sources**
- [circular-buffer.cc](file://sherpa-onnx/csrc/circular-buffer.cc)

## 内存泄漏检测

内存泄漏检测可以通过以下方法进行：
1. 启用地址 sanitizer：在`CMakeLists.txt`中设置`SHERPA_ONNX_ENABLE_SANITIZER=ON`，编译时会插入内存检查代码。
2. 使用Valgrind：在Linux系统上运行Valgrind检测内存错误。
3. 代码审查：特别注意动态内存分配（如`new`/`delete`）的配对使用。

在`axera/utils.cc`中，`FreeIO`函数负责释放NPU相关的内存资源，需要确保每个`AX_SYS_MemFree`调用都有对应的分配操作。对于C++对象，建议使用智能指针（如`std::unique_ptr`）自动管理生命周期。

**Section sources**
- [CMakeLists.txt](file://CMakeLists.txt)
- [utils.cc](file://sherpa-onnx/csrc/axera/utils.cc)